import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
    id 'net.neoforged.moddev' version '2.0.134'
}

apply from: rootProject.file('buildscript/relocations.gradle')
apply from: rootProject.file('buildscript/final.gradle')

configurations.configureEach {
    resolutionStrategy {
        force "org.slf4j:slf4j-api:1.7.36" // Introduced by Minecraft itself
    }
}

java {
    targetCompatibility = JavaVersion.VERSION_21
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenLocal()
}

neoForge {
    version = "21.11.17-beta"
}

shadowJar {
    setProperty("zip64", true)
}

gradle.projectsEvaluated {
    def modded = rootProject.findProject('modded')
    if (!modded) {
        logger.warn("':modded' project not found; skipping neoforge dynamic includes")
        return
    }

    def matches = modded.subprojects.findAll { it.name?.endsWith('-neoforge') }
    if (matches.isEmpty()) {
        logger.lifecycle("No modded *-neoforge subprojects found; nothing to bundle into neoforge")
        return
    }

    matches.each { neoforgeProject ->
        def taskName = "${neoforgeProject.name.split("-")[0]}-shadowJar"

        def neoforgeVersionShadowJar = tasks.register(taskName, ShadowJar) { sj ->
            sj.setProperty("zip64", true)
            sj.configurations = [project.configurations.shadow]

            sj.archiveBaseName = "DiscordSRV-${neoforgeProject.property('loom.platform').capitalize()}-${neoforgeProject.property('minecraft.version_range_label')}"
            sj.archiveClassifier = jar.archiveClassifier

            sj.from({
                def nf = rootProject.findProject('neoforge')
                if (nf != null && nf.hasProperty('sourceSets')) {
                    return nf.sourceSets.main.output
                }
                return []
            })

            sj.from({
                def processed = file("${neoforgeProject.buildDir}/resources/main")
                if (processed.exists()) {
                    return files(processed)
                }
            }) {
                into ''
            }

            sj.dependsOn("${neoforgeProject.path}:transformProductionNeoForge")
            sj.from({
                def inFile = file("${neoforgeProject.projectDir}/build/libs/neoforge.jarinjar")
                if (inFile.exists()) return files(inFile)
                return []
            }) {
                into '/'
                rename { 'neoforge.jarinjar' }
            }
        }

        tasks.named('assemble') { it.dependsOn(neoforgeVersionShadowJar) }
    }
}

dependencies {
    // API
    annotationProcessor project(':api')
    implementation project(':common:common-api')

    // Common
    implementation project(':common')

    // DependencyDownload
    shadow(libs.mcdependencydownload.neoforge.loader)
}