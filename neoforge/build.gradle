import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
    id 'net.neoforged.moddev' version '2.0.134'
}

apply from: rootProject.file('buildscript/relocations.gradle')
apply from: rootProject.file('buildscript/final.gradle')

configurations.configureEach {
    resolutionStrategy {
        force "org.slf4j:slf4j-api:1.7.36" // Introduced by Minecraft itself
    }
}

java {
    targetCompatibility = JavaVersion.VERSION_21
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenLocal()
    maven { url = "https://maven.neoforged.net/releases" }
}

neoForge {
    version = "21.1.217"
}

shadowJar {
    setProperty("zip64", true)
}

gradle.projectsEvaluated {
    def modded = rootProject.findProject('modded')
    if (!modded) {
        logger.warn("':modded' project not found; skipping neoforge dynamic includes")
        return
    }

    def matches = modded.subprojects.findAll { it.name?.endsWith('-neoforge') }
    if (matches.isEmpty()) {
        logger.lifecycle("No modded *-neoforge subprojects found; nothing to bundle into neoforge")
        return
    }

    matches.each { neoforgeProject ->
        def taskName = "${neoforgeProject.name.split("-")[0]}-shadowJar"

        def neoforgeCopyShadowJar = tasks.register("${neoforgeProject.name.split("-")[0]}-copyOutput", Copy) {
            from tasks.named(taskName).get().archiveFile
            into rootProject.file("jars/neoforge")
        }

        // metadata.json inside /META-INF/jarjar/
        def neoforgeResources = tasks.register("${neoforgeProject.name.split("-")[0]}-processResources", Copy) {
            from sourceSets.main.resources.srcDirs
            into "${neoforgeProject.projectDir}/build/processIncludeJar"
            filesMatching('metadata.json') {
                expand(ADVENTURE_VERSION: neoforgeProject.property('deps.adventure_platform'))
            }

            include 'metadata.json'
            dependsOn neoforgeProject.tasks.named('processResources')
            mustRunAfter neoforgeProject.tasks.named('processResources')
        }

        def neoforgeShadowJar = tasks.register(taskName, ShadowJar) { sj ->
            sj.setProperty("zip64", true)
            sj.configurations = [project.configurations.shadow]
            mergeServiceFiles()

            sj.archiveBaseName = "DiscordSRV-${neoforgeProject.property('loom.platform').capitalize()}-${neoforgeProject.property('minecraft.version_range_label')}"
            sj.archiveClassifier = jar.archiveClassifier
            sj.manifest = neoforgeProject.tasks.named('shadowJar').get().manifest

            sj.from({
                def nf = rootProject.findProject('neoforge')
                if (nf != null && nf.hasProperty('sourceSets')) {
                    return nf.sourceSets.main.output
                }
                return []
            })

            sj.dependsOn(
                    "${neoforgeProject.path}:remapJar"
            )
            sj.from({
                def inFile = file("${neoforgeProject.projectDir}/build/libs/neoforge.jarinjar")
                if (!inFile.exists()) return []
                return zipTree(inFile).matching {
                    include 'dependencies/**'
                    include 'META-INF/neoforge.mods.toml'
                }
            }) {
                into '/'
            }

            sj.from({
                def includeJarDir = file("${neoforgeProject.projectDir}/build/processIncludeJar")
                if (includeJarDir.exists()) return includeJarDir
                return []
            }) {
                into '/META-INF/jars'
            }

            // META-INF/jarjar/metadata.json
            sj.from(neoforgeResources) {
                into '/META-INF/jarjar'
            }

            sj.from({
                def inFile = file("${neoforgeProject.projectDir}/build/libs/neoforge.jarinjar")
                if (inFile.exists()) return files(inFile)
                return []
            }) {
                into '/'
                rename { 'neoforge.jarinjar' }
            }

            tasks.shadowJar.relocators.each { relocator -> {
                sj.relocate(relocator)
            }}

            finalizedBy neoforgeCopyShadowJar
        }

        tasks.named('assemble') { it.dependsOn(neoforgeShadowJar) }
    }
}

dependencies {
    // API
    annotationProcessor project(':api')
    shadow project(':common:common-api')

    // Common
    compileOnly project(path: ':common', configuration: 'runtimeElements')

    // DependencyDownload
    shadow(libs.mcdependencydownload.neoforge.loader) {
        exclude group: 'net.neoforged.accesstransformer', module: 'modlauncher'
    }
}